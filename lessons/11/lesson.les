## CSS - Блоки

В HTML все элементы можно разделить на два типа: блочные и строчные.

Блочные элементы визуально создают самостоятельную структурную единицу - блок. К ним можно отнести, например, элементы H1-H6, P, DIV. Такие элементы отделяются от других абзацными отступами.

Строчные элементы выводятся линейной строкой. К ним можно отнести, например, элементы I, B, U, S и другие.

В CSS модель документа представляется блоком. Каждый элемент в дереве элементов документа представляет собой самостоятельный блок. Причем, есть блоки, структурно отделенные от остальных, а есть строчные блоки, которые могут находиться внутри структурных блоков.

Блок имеет прямоугольную форму.

Итак, у блока есть содержимое, например, для элемента p - это текст. Вокруг содержимого есть отступы (padding), они служат для того, чтобы текст не примыкал вплотную к границе блока. Фон отступов такой же, как и у содержимого. 

Затем идет граница блока (border), которая может быть как видимой, так и невидимой.

Также блок имеет поля (margin), которые задают дополнительное свободное пространство вокруг блока. Фон полей прозрачный, т.е. сквозь него просвечивает фон родительского элемента. 

Размер блока, т.е. его ширина (width) и высота (height), определяются содержимым. И это надо запомнить: поля и отступы не учитываются в размере блока.

Способы задания всех этих свойств мы рассмотрим позже, а пока, чтобы стало понятнее, приведем пример. Пусть у нас есть html-страница с двумя абзацами:

<html>
  <head>
    <title>Заголовок документа</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <p>Текст в параграфе.</p>
    <p>Текст в параграфе.</p>
  </body>
</html>
    
Для того, чтобы увидеть отступы, поля и границы, зададим границу (пока не вдаваясь в подробности из чего она состоит):

p{
  border:1px solid red;
}
    


Сейчас наша страница в браузере выглядит так:



Как мы уже знаем, отступы от границы задаются свойством padding, зададим его для параграфов:

p{
  border:1px solid red;
  padding:10px;
}
    


Теперь у нас есть отступы внутри блока. Задание полей отделит блоки друг от друга:

p{
  border:1px solid red;
  padding:10px;
  margin:50px;
}
    


Наконец, зададим размеры блоков параграфов:

p{
  border:1px solid red;
  padding:10px;
  margin:50px;
  width:100px;
  height:50px;
}
    


Таким образом, как вы уже наверно догадались, можно располагать элементы на странице так, как нам захочется. И заметьте без всяких таблиц и обилия кода. Именно на понятиях блоков строится блочная верстка сайта.

# Виды и свойства Блоков CSS

Как вы помните, элементы могут быть блочными и строчными (урок 8). По умолчанию для каждого элемента его вид определен, так элементы div и p являются блочными, а span и a - строчными. Но иногда это необходимо изменить, для этого используется свойство display. Это свойство может принимать одно из четырех значений. Рассмотрим все четыре на примерах.

display:block

Это значение делает элемент блочным. Предположим, мы решили сделать вертикальное меню. Для этого на html-странице мы напишем следующий код:

<html>
  <head>
    <title>css display</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <div id="menu">
     <a href="index.html">Главная</a>
     <a href="about_us.html">О нас</a>
     <a href="contact.html">Контакты</a>
    </div>
  </body>
</html>
    
Зададим на странице style.css стиль для наших ссылок, причем только для ссылок, которые находятся в div-е с id="menu" (тогда другие ссылки на странице, если они будут, останутся без изменения или им можно будет задать другой стиль):

#menu{
 width:200px;
 background:yellow;
}
#menu a{
 color:#2b3845;
 text-decoration:none;
}
#menu a:hover{
 color:#92A9BF;
 background:blue;
}
    
Элемент a является строчным, поэтому наши ссылки расположились в одну строку и их размер зависит от текста. Но мы хотели сделать вертикальное меню, для этого мы и добавим нашим ссылкам свойство display:block:

#menu{
 width:200px;
 background:yellow;
}
#menu a{
 color:#2b3845;
 text-decoration:none;
 display:block;
}
#menu a:hover{
 color:#92A9BF;
 background:blue;
}
    
Обратите внимание, так как теперь наши ссылки стали блочными элементами, то и размер у них стал одинаковый, равный ширине родительского div-а.

display:inline

Это значение делает элемент строчным. Предположим, мы хотим разместить на странице параграф, который должен начинаться с заголовка. На html-странице мы напишем следующий код:

<html>
  <head>
    <title>css display</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <h5>Заголовок.</h5> <p>Текст параграфа</p>
  </body>
</html>
    

Добавим на страницу style.css стили для наших элементов:

h5, p{
 display:inline;
}
    
Теперь наша страница выглядит так, как мы и хотели.

display:list-item

Это значение делает любой элемент частью списка. Используется он редко, да и поддерживается браузерами не в полной мере. Но давайте все-таки посмотрим пример. Пусть у нас есть три заголовка одного уровня, и мы хотим оформить их списком. Для этого на html-странице мы напишем:

<html>
  <head>
    <title>css display</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <ul>
    <h6>Заголовок</h6>
    <h6>Заголовок</h6>
    <h6>Заголовок</h6>
   </ul>
  </body>
</html>
    
На странице стилей напишем всего одно свойство:

h6{
 display:list-item;
}
    
display:none

Это значение убирает элемент со страницы. Очень часто используется для формирования раскрывающихся меню сайтов, например, с помощью языка javascript. Вы, наверно, встречали такие меню, где при щелчке по пункту меню раскрывается список подпунктов. Вот в таких меню и используется значение display:none.

Надо сказать, что в CSS есть еще одно свойство на первый взгляд похожее на display:none. Это свойство, отвечающее за видимость блока - visibility. Оно может принимать два значения: visible (отображать) и hidden (сделать невидимым).

Различия здесь следующее: display:none скрывает элемент, как будто его и не было, а visibility:hidden делает элемент прозрачным. Понятнее будет на примере. Пусть у нас есть пять параграфов:

<html>
  <head>
    <title>css display</title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <p>Параграф 1</p>
    <p id="p2">Параграф 2</p>
    <p>Параграф 3</p>
    <p id="p4">Параграф 4</p>
    <p>Параграф 5</p>
  </body>
</html>
    

Давайте зададим для второго параграфа свойство display:none, а для четвертого - свойство visibility:hidden:

#p2{
 display:none;
}
#p4{
 visibility:hidden;
}
    

Как видите, второй параграф отсутствует, а четвертый - невидим, но место под него оставлено. В этом и заключается разница. Свойство visibility так же, как и свойство display, чаще всего применяется совместно с javascript.
Отображение содержимого блоков в разных браузерах
Как вы думаете, что будет, если блочному элементу задать меньшие размеры, чем его содержимое? Ваш ответ будет зависеть от того, в каком браузере вы работаете. Предположим мы задали блоку размер 200х100 пикселов и поместили в него текст, явно превышающий эти размеры. Ниже приведен рисунок, где отображено поведение различных браузеров в такой ситуации:


Как видите, одни браузеры растягивают блоки, чтобы вместить содержимое, а другие перекрывают блок содержимым. Конечно, лучшего всего контролировать размеры объектов, но это не всегда возможно. Как же быть тогда? Воспользоваться свойством overflow. Это свойство может принимать четыре значения:
visible - если содержимое превышает размеры блока, оно все-равно останется на экране. Результат будет такой же, как на рисунке выше.


hidden - браузер отрежет содержимое, которое превышает размер блока.

scroll - блок будет снабжен полосами прокрутки, причем как горизонтальной, так и вертикальной.
Здесь располагается какой-либо текст, который явно не помещается в указанные размеры блока. И в этом случае текст будет по-разному отображаться в различных браузерах.

auto - блок будет снабжен только теми полосами прокрутки, которые необходимы.
Здесь располагается какой-либо текст, который явно не помещается в указанные размеры блока. И в этом случае текст будет по-разному отображаться в различных браузерах.

Надо сказать, что на практике свойство overflow используется редко, но знать о его существовании все-таки стоит. 